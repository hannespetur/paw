//==================================================================================================
/*!
  @file

  @copyright 2017 NumScale SAS

  Distributed under the Boost Software License, Version 1.0.
  (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
**/
//==================================================================================================
#ifndef BOOST_SIMD_ALGORITHM_GENERATE_HPP_INCLUDED
#define BOOST_SIMD_ALGORITHM_GENERATE_HPP_INCLUDED

#include <boost/simd/range/segmented_aligned_range.hpp>
#include <boost/simd/as.hpp>
#include <boost/simd/pack.hpp>

namespace boost { namespace simd
{
  /*!
    @ingroup group-algo

    Assigns each element in range [first, last) a value generated by
    the successive calls to the given function object @c g.

    @param first  Beginning of the range of elements
    @param last   End of the range of elements
    @param g      unary function object to generate elements

    @par Requirement

      - @c first, @c last and @c out must be pointer to Vectorizable type.

      - @c g must be a Polymorphic Unary function object. Its prototype must be
          <tt>T g(boost::simd::as_<T>)</tt> as g can be called for scalars and packs
          and must have a way to discriminate its return type.

    @warningbox{The expectd signature for @c g is not the one of the standard algorithm.}

    @par Example:

      @snippet generate.cpp generate

    @par Possible output:

      @snippet generate.txt generate

  **/
  template<typename T, typename Gen> void generate(T* first, T* last, Gen g)
  {
    auto pr = segmented_aligned_range(first,last);
    std::generate(pr.head.begin(), pr.head.end(), [&g](){return g(as_<T>());        });
    std::generate(pr.body.begin(), pr.body.end(), [&g](){return g(as_<pack<T>>());  });
    std::generate(pr.tail.begin(), pr.tail.end(), [&g](){return g(as_<T>());        });
  }
} }

#endif
